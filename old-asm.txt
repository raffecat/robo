
; Code    = SRCL   ; BASIC code ptr low  (DMA source)
; CodeH   = SRCL+1 ; BASIC code ptr high (DMA source)

MACRO _LDA_DMA
  JSR dma_lda     ; debugger, no HW
ENDM
MACRO _LDX_DMA
  JSR dma_ldx     ; debugger, no HW
ENDM
MACRO _LDY_DMA
  JSR dma_ldy     ; debugger, no HW
ENDM
MACRO _DISPATCH
    JMP dma_jmpt  ; debugger, no HW
ENDM

; ; Simulates "LDA DDRW" (DMA read)
; dma_lda:
;     STY YSave
;     LDY #0
;     LDA (Code),Y
;     LDY YSave
;     INC Code
;     BCS dma_rd_adv
;     RTS
; dma_rd_adv:
;     INC Code+1
;     RTS
; 
; ; Simulates "LDX DDRW" (DMA read)
; dma_ldx:
;     STY YSave
;     LDY #0
;     LDX (Code),Y
;     LDY YSave
;     INC Code
;     BCS dma_rd_adv
;     RTS
; 
; ; Simulates "LDY DDRW" (DMA read)
; dma_ldy:
;     STA YSave
;     LDY #0
;     LDA (Code),Y
;     TAY
;     LDA YSave
;     INC Code
;     BCS dma_rd_adv
;     RTS
; 
; ; Simulates DMA jump-table hardware
; dma_jmpt:
;     JSR dma_lda
;     LDA bas_jump,X
;     STA JtA
;     LDA bas_jump+1,X
;     STA JtA+1
;     JMP (JtA)


  LDA #DMA_M2V|DMA_Fill  ; [2] DMA mode (M2M,Fill)
  STA DCTL               ; [3] set fill mode
  ; zero page
  LDX #2                 ; [2] skip the first two bytes of zero-page for pointer use  [26 bytes]
  STX DSTL               ; [3] set DMA dest low (=2)
  STX $00                ; [3] set pointer low (=2)
  LDX #$00               ; page byte = zero page
  LDA #$55               ; fill byte
  LDY #$BE               ; $C0-2 bytes below IO area
  JSR @memcheck          ; fill and compare with $55 (preserves A,X)
  LDA #$AA               ; fill byte
  LDY #$BE               ; $C0-2 bytes below IO area
  JSR @memcheck          ; fill and compare with $AA (preserves A,X)
  STX DSTL               ; set DMA dest low (=0)
  STX $00                ; set pointer low (=0)
  ; stack page
  INX                    ; page byte = page 1
  LDA #$55               ; fill byte
  LDY #$FC               ; $FF-4 bytes below stack in use (2 calls)
  JSR @memcheck          ; fill and compare with $55 (preserves A,X)
  LDA #$AA               ; fill byte
  LDY #$FC               ; $FF-4 bytes below stack in use (2 calls)
  JSR @memcheck          ; fill and compare with $AA (preserves A,X)
  ; remaining pages



parse_num:       ; from (Src),Y returning Y=end, X=len
  LDX #0         ; [2] clear Acc
  STX Acc0       ; [3]
  STX Acc1       ; [3]
  STX Acc2       ; [3]
  STX Acc3       ; [3] [14]
@loop:           ; -> 15+122+40 [177]
  LDA (Src),Y    ; [4] get char
  SEC            ; [2]
  SBC #48        ; [2] make '0' be 0 (CF -> 0|1)
  CMP #10        ; [2]
  BCS @done      ; [2] >= 10 -> done
  STA Tmp        ; [3] save digit 0-9  [15]
  JSR acc_mul_10 ; [116] uses A (+Acc,+Term)
  CLC            ; [2]
  LDA Acc0       ; [3]
  ADC Tmp        ; [3] add digit 0-9   (acc_add_byte)
  STA Acc0       ; [3]
  LDA Acc1       ; [3]
  ADC #0         ; [2]
  STA Acc1       ; [3]
  LDA Acc2       ; [3]
  ADC #0         ; [2]
  STA Acc2       ; [3]
  LDA Acc3       ; [3]
  ADC #0         ; [2]
  STA Acc3       ; [3]
  INX            ; [2]
  JMP @loop      ; [3] [40]
@done:
  RTS

; multiply Acc by 10 (uses Term)
acc_mul_10:     ; Uses A (+Term)
  LDA Acc0      ; [3] Term = Val * 2
  ASL           ; [2]
  STA Term0     ; [3]
  LDA Acc1      ; [3]
  ROL           ; [2]
  STA Term1     ; [3]
  LDA Acc2      ; [3]
  ROL           ; [2]
  STA Term2     ; [3]
  LDA Acc3      ; [3]
  ROL           ; [2]
  STA Term3     ; [3] 32
  ASL Term0     ; [5] Term = Term * 2 = Val * 4
  ROL Term1     ; [5]
  ROL Term2     ; [5]
  ROL Term3     ; [5] 20
  CLC           ; [2]
  LDA Acc0      ; [3] Acc = Acc + Term = Val * 5   (acc_add_term)
  ADC Term0     ; [3]
  STA Acc0      ; [3]
  LDA Acc1      ; [3]
  ADC Term1     ; [3]
  STA Acc1      ; [3]
  LDA Acc2      ; [3]
  ADC Term2     ; [3]
  STA Acc2      ; [3]
  LDA Acc3      ; [3]
  ADC Term3     ; [3]
  STA Acc3      ; [3] 12*3+2 38
  ASL Term0     ; [5] Acc = Acc * 2 = Val * 10
  ROL Term1     ; [5]
  ROL Term2     ; [5]
  ROL Term3     ; [5] 20
  RTS           ; [6] -> [116]

