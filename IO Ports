IO Ports

Considerations:
• BASIC will use DMA source streaming (read DDRW) to read code;
  • No point having DMA bank registers; physical RAM is non-contiguous.
• Text output will use DMA destination streaming (write DDRW) to output text;
• Need direct access to palette and sprite memory for fast per-scanline changes;
• HDMA: per-scanline scroll, per-scanline palette change, sample playback?
        (can use YCMP and CPU interrupt instead; C64 only had this)
• DMA setup is expensive (5*6=30 cycles just to load constants!)
  • DMA fastload: LDA #zp; STA IO_DFLD; loads 6 bytes from zero-page in 6 cycles (8-aligned)

How do you draw lines?
• use APA-mode; write pointer in DSTL,DSTH [saves 5+5+2 = 12 cycles]
• increment DSTL by 1 (X-basis) or by screen width [expensive] (Y-basis)
• conditionally add screen width [expensive] (X-basis) or 1 (Y-basis)
• store color into DDRW after updating address

How do you fill scanlines of a triangle/rectangle?
• use fill-mode to fill complete bytes (pixel divisor depends on BPP)
• switch to APA-mode to draw part-byte endpoints?
• fill-mode needs byte address: shift down (truncate) fill-mode address

How would you emulate Raster OPs without ROP HW?
• APA mode, VRAM to VRAM, same SRC and DST
• TXA color [2] AND|OR|EOR DDRW [3] STA DDRW [3] total [8] per px
• (hspan:) decrement [2] and loop [3] -> 8+5 = 13 cycles (vs DMA 2 cycles!) per px
• (line:) uses an APA loop already -> extra [+5] cycles per px


IO Registers

IO_SRCL    = $D0    ; DMA src low         (r/w: DMA uses current BNK8/BNKC mapping)
IO_SRCH    = $D1    ; DMA src high        (r/w: BASIC must handle bank-crossing due to non-contiguous RAM)
IO_DSTL    = $D2    ; DMA dest low        (r/w)
IO_DSTH    = $D3    ; DMA dest high       (r/w)
IO_DCTL    = $D4    ; DMA control         (r/w: 7-6:direction 5:vertical 4:reverse 2-0:mode)
IO_DRUN    = $D5    ; DMA count           (write: start DMA, 0=256; read: increment DST += 640)
IO_FILL    = $D6    ; DMA fill byte       (write: set FILL byte [data latch]; read: last value to/from IO_DDRW)
IO_DDRW    = $D7    ; DMA data R/W        (read: reads from src++; write: writes to dest++)
IO_DJMP    = $D8    ; DMA jump indirect   (read: indirect table jump [stalls for +1 cycle]; write: set Jump Table [page latch])
IO_APWR    = $D9    ; DMA APA write       (read: second byte of indirect jump; write: triggers APA write cycle, writes [page latch])
IO_BNK8    = $DA    ; Bank switch $8000   (low 6 bits)
IO_BNKC    = $DB    ; Bank switch $C000   (low 6 bits)
-------    = $DC    ; 
-------    = $DD    ; 
IO_KEYB    = $DE    ; Keyboard scan       (write: set row; read: column bitmap)
IO_MULW    = $DF    ; Booth multiplier?   (write {AL,AH,BL,BH} read {RL,RH})

DCTL direction:                        [implementation: drives different chip-enables]
    0 = mem -> mem                     
    1 = mem -> vram                    
    2 = vram -> mem                    
    3 = vram -> vram                   (can be used for windowed scrolling)
DCTL vertical:                         (increments [Dest] by current map width in VMAP [column upload])
DCTL reverse:                          (derements src and dest addresses [memmove])
DCTL mode:                             [ALWAYS 2-cycles/byte due to counter increment cycle]
    0 = copy                           (copy bytes)
    1 = fill                           (using FILL byte [data latch])
    2 = copy transparent               (copy bytes, skip zero bytes)
    3 = APA mode (RMW)                 (APA addressing: low 3 bits of address select pixel)
    4 = palette memory                 (src/dest is palette memory; 8-bit addr, ignores direction)
    5 = sprite memory                  (src/dest is sprite memory; 8-bit addr, ignores direction)
    6 = clear sprites                  (write $FF to Y coords in sprite memory; 8-bit addr, ignores direction)

TON0    = $E0    ; PSG Ch.0 tone
PCH0    = $E1    ; PSG Ch.0 pitch
VOL0    = $E2    ; PSG Ch.0 volume
TON1    = $E3    ; PSG Ch.1 tone
PCH1    = $E4    ; PSG Ch.1 pitch
VOL1    = $E5    ; PSG Ch.1 volume
TON2    = $E6    ; PSG Ch.2 tone
PCH2    = $E7    ; PSG Ch.2 pitch
VOL2    = $E8    ; PSG Ch.2 volume
TON3    = $E9    ; PSG Ch.3 tone
PCH3    = $EA    ; PSG Ch.3 pitch
VOL3    = $EB    ; PSG Ch.3 volume
GP0R    = $EC    ; Game port 0 read
GP1R    = $ED    ; Game port 1 read
----    = $EE
----    = $EF

YLIN    = $F0    ; current Y-line         (read: V-counter; write: wait for VBlank)                      [LIVE]
YCMP    = $F1    ; compare Y-line         (read/write, $FF won't trigger interrupt)
SCRH    = $F2    ; horizontal scroll      (tile offset from 0, wraps)                      [Reloads End HBLANK]
SCRV    = $F3    ; vertical scroll        (row offset from 0, wraps)                                     [LIVE]
FINH    = $F4    ; horizontal fine scroll (top 3 bits)                                     [Reloads End HBLANK]
FINV    = $F5    ; vertical fine scroll   (top 3 bits)                                                   [LIVE]
VCTL    = $F6    ; video control          (7:APA 6:Grey 5:Double 4:HCount 3-2:VCount 1-0:Divider)        [LIVE]
VENA    = $F7    ; interrupt enable       (7:VSync 6:VCmp 5:HSync 3:BG_En 2:Spr_En)                      [LIVE]
VSTA    = $F8    ; interrupt status       (7:VSync 6:VCmp 5:HSync)  (read:status / write:clear)          [LIVE]
VMAP    = $F9    ; name table size        (4:4 width 32,64,128,256; height 32,64,128,256)                [LIVE]
VTAB    = $FA    ; name table base        (high byte)                                                    [LIVE]
VBNK    = $FB    ; tile bank R/W          (write: [aaaadddd] bank addr,data; read: [aaaa----] read data) [LIVE]
PALA    = $FC    ; palette address        (direct palette-memory address, top bit enables auto-inc)      [LIVE]
PALD    = $FD    ; palette data R/W       (direct palette-memory data)                                   [LIVE]
PALA    = $FE    ; sprite address         (direct sprite-memory address, always auto-increment)          [LIVE]
PALD    = $FF    ; sprite data R/W        (direct sprite-memory data)                                    [LIVE]

VCTL register [ANCGVVHD] set video mode:
(7) APA mode (A) direct [non-tiled] VRAM addressing fixed at address 0
(6) Narrow mode (N) render the left 5 pixels of each tile (64-column text mode)   [not APA]
(5) 16 Color (C) attributes contain [BBBBFFFF] BG,FG colors (2x16 palettes)       [not APA]
(4) Greyscale (G) disables Colorburst for improved text legibility
(3-2) Vertical (VV) is 0=192 1=200 2=224 3=240 visible lines per frame
(1) Horizontal (H) is 0=256 1=320 visible pixel-clocks per line (shift rate)
(0) Divider (D) is 0=256|320 (2bpp) 1=128|160 (4bpp)

VCTL_APA       = $80   ; linear framebuffer at address 0 (or linear 8x8 tiles?)
VCTL_NARROW    = $40   ; 5x8 tiles at 2bpp only; left 5 pixels of each tile (64 columns)
VCTL_16COL     = $20   ; attributes contain [BBBBFFFF] BG,FG colors (2+2x16 colours)
VCTL_LATCH     = $20   ; in APA mode, latch color on zero (filled shapes mode)
VCTL_GREY      = $10   ; disable Colorburst for text legibility
VCTL_V240      = $0C   ; 240 visible lines per frame
VCTL_V224      = $08   ; 224 visible lines per frame
VCTL_V200      = $04   ; 200 visible lines per frame
VCTL_V192      = $00   ; 192 visible lines per frame
VCTL_H320      = $02   ; 320 visible pixels per line (shift rate)
VCTL_H256      = $00   ; 256 visible pixels per line (shift rate)
VCTL_4BPP      = $01   ; divide clock by 4, use 4 bits per pixel (double-width)
VCTL_2BPP      = $00   ; divide clock by 2, use 2 bits per pixel (square pixels)


Pixel latch rate is determined by divider (D)
Pixel shift rate fixed, with 256/320 clocks per line (H)
In 'APA' mode, (N) is ignored and (C) is reinterpreted as Latch mode.
In 'Narrow' mode (N) tiles are still 8x8x2 in memory, but only the left 5 columns are displayed.
In '16 Color' mode, pixel values 0=BG 1=FG 2=16+BG 3=16+FG

VENA register [VCH-PLSB] video enable:
(7) VSync Interrupt enable (V)
(6) VCmp Interrupt enable (C)
(5) HSync Interrupt enable (H)
(3) Power LED (P)
(2) Caps Lock LED (L)
(1) Sprite enable (S)
(0) Background enable (B)


DMA-APA Mode:

Configure VRAM -> VRAM mode, same SRC and DST address.
Mask isolates one pixel, indexed by low bits of address.
Trigger mode: CPU writes FILL byte, triggers one DMA cycle (varying FILL or Address)
[ Counted mode: CPU presets FILL byte, then sets RUN count (limited use vs DMA fill) - REMOVED ]
Read cycle -> DL
Write cycle <- DL & ~mask | FILL & mask
Write replaces DL bits with 1/2/4 quarters of FILL byte.
Trigger e.g. line draw, dashed line, graphics scaling.
[ Counted e.g. last few partial-byte pixels on a span? - REMOVED ]
[ Write cycle <- DL & ~mask | (ROP-result) & mask  [when ROP enabled] - REMOVED ]
^ 8x 2-way AND-OR selector ~24 gates, well worth it for line/edge accel,
  especially combined with a color-latching video mode
APA writes are always triggered by writing to IO_APJP, which replaces the [page latch]

FILL byte is shared with JTAB page to keep register count low.
After using APA DMA-mode, the jump table page must be restored.



HDMA REMOVED - YLIN and its Interrupt are enough.

HDMA data format:
00000000 nnnnnnnn  - wait for YLine 'n' (sets YCMP)
00000000 FFFFFFFF  - generate HSync interrupt
aaaaaaaa dddddddd  - write byte 'd' at address 'a'

Implementation: 12-bit counter (low 16 pages), 8-bit YReg for "wait for YLine" (reuse YCMP?)

Can use HDMA to play samples (need to unpack 64 samples per frame: 64*4=256 bytes: 0,YLine,IO,sample)
every 4th line. Can unpack 1-bit delata modulation with ASL;ADC;STA loop. Too much work.




DMA ROP modes REMOVED - not worth the HW cost.

AROP register [-----IRR] APA Raster Op:
(2) Invert the result
(1-0) Operator: 0=Nop 1=OR 2=AND 3=XOR

ROP mode:
Configure VRAM -> VRAM mode, same SRC and DST address.
Trigger mode: CPU writes FILL byte, triggers one DMA cycle (varying FILL byte)
Counted mode: CPU presets FILL byte, then sets RUN count (constant FILL byte)
Read cycle -> DL
Write cycle <- (DL NOP|AND|OR|XOR FILL)
(trigger e.g. xor cursor draw)
(counted e.g. filled spans drawn with ROPs [demos])
[ROP-result selects (DL)|(DL-AND-FILL)|(DL-OR-FILL)|(DL-XOR-FILL) result (AND-OR)]
^ this is a lot of gates: 3*8+4*8+8 = 64, may not be worth it,
  could better spend these gates on a color-latching video mode

It may be worth including 8 XOR gates (DL XOR FILL) to provide "Invert" mode,
since that's the most common use for ROPs (cursor, selection rect)
~16 gates (8 x XOR + 8 x AND FILL to disable)
OR just an invert bit: 8 x XOR only.


Without ROP HW:

Selection Rect:
Horizontal: LDA DDRW; XOR $FF; STA DDRW; DEY; BNE [13 cycles/byte, 6.5 cycles/px at 4bpp]
Vertical: mask = $03 (2bpp) or $0F (4bpp) pre-shifted to pixel column.
Vertical: LDA DDRW; XOR mask; STA DDRW; DEY; BEQ done; TXA; ADC DSTL; STA DSTL; BCC loop; ... [24 cycles/px]

Line Draw:
loop: STX DDRW; [C=0] ADC dy2; BCS step; DEC dx; BNE loop [16]  ; X steps (A=error X=color Y=temp)   step+9
step: [C=1] SBC dx2; TAY; LDA #64; CLC; ADC DSTL; STA DSTL; LDA #1; ADC DSTH; STA DSTH; TYA; DEC dx; BNE loop [33+9=42] ; Y step

(This doesn't include Y-clipping, i.e. stopping at the top/bottom edge.)

These would benefit from a fast way to increment DST by 640 [even if it takes 2 clocks],
which wouldn't take a full adder: 640=512+128 [in APA modes]
This can be implemented as extra increment cycles applied to higher bits of
the DST counter (b7,b5; b8,b6), manually triggered by a CPU write.
(Text modes would benefit from an increment by map-width, resetting all bits below.)

Fast-Inc Line Draw:  (~2000 pixels per frame)
loop: STX DDRW; [C=0] ADC dy2; BCS step; DEY; BNE loop [13]  ; X steps (X=color Y=dx)  step+9
step: STA DINC; [C=1] SBC dx2; DEY; BNE loop      [9+11=20]  ; Y step (DINC ignores A)

This routine only works for short lines, up to 63 in each of dx and dy,
assuming the classic 2*dx, 2*dy approach.

The midpoint formulation will work up to 127 in each of dx, dy:
D = dx/2;
for (x = x0; x <= x1; x++) {
    plot(x, y);
    D -= dy;
    if (D < 0) { y++; D += dx; }
}

Fast-Inc Line Draw:
LDA dx; ASR; SEC
loop: STX DDRW; [C=1] SBC dy; BCC step; DEY; BNE loop [13]  ; X steps, while D>=0 (X=color)
step: STA DINC; [C=0] ADC dx; DEY; BNE loop      [9+11=20]  ; Y step (Y=dx; DINC ignores A)

Fast-Inc 16-bit Line Draw:
LDA dxh; CMP #$80; ROR A; STA ehi; LDA dxl; ROR A; STA elo                                      ; CMP #$80 sets C=sign-bit
loop: STX DDRW; SEC; LDA elo; SBC dyl; STA elo; LDA ehi; SBC dyh; STA ehi; DEY; BPL loop [26]   ; X steps, while D>=0 (X=color)
step: STA DINC; CLC; LDA elo; ADC dxl; STA elo; LDA ehi; ADC dxh; STA ehi; DEY; BNE loop [+28]  ; Y step (DINC ignores A)

Better to break lines into 127-pixel segments.
