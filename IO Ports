IO Ports

Considerations:
• BASIC will use DMA source streaming (read DDRW) to read code;
  • No point having DMA bank registers; physical RAM is non-contiguous.
• Text output will use DMA destination streaming (write DDRW) to output text;
• Need direct access to palette and sprite memory for fast per-scanline changes;
• HDMA: per-scanline scroll, per-scanline palette change, sample playback?
        (can use YCMP and CPU interrupt instead; C64 only had this)
• DMA setup is expensive (5*6=30 cycles just to load constants!)
  • DMA fastload: LDA #zp; STA IO_DFLD; loads 6 bytes from zero-page in 6 cycles (8-aligned)

How do you draw lines?
• use APA-mode; write pointer in DSTL,DSTH [saves 5+5+2 = 12 cycles]
• increment DSTL by 1 (X-basis) or by screen width [expensive] (Y-basis)
• conditionally add screen width [expensive] (X-basis) or 1 (Y-basis)
• store color into DDRW after updating address

How do you fill scanlines of a triangle/rectangle?
• use fill-mode to fill complete bytes (pixel divisor depends on BPP)
• switch to APA-mode to draw part-byte endpoints?
• fill-mode needs byte address: shift down (truncate) fill-mode address

How would you emulate Raster OPs without ROP HW?
• APA mode, VRAM to VRAM
• TXA color [2] AND|OR|EOR DDRW [3] STA DDRW [3] total [8] per px
• (hspan:) decrement [2] and loop [3] -> 8+5 = 13 cycles (vs DMA 1 cycle!) per px
• (line:) uses an APA loop already -> extra 8-3 = [5] cycles per px


IO Registers

SRCL    = $D0    ; DMA src low         (DMA uses current BNK8/BNKC mapping)
SRCH    = $D1    ; DMA src high        (BASIC must handle bank-crossing due to non-contiguous RAM)
DSTL    = $D2    ; DMA dest low
DSTH    = $D3    ; DMA dest high
DCTL    = $D4    ; DMA control         (7-6:direction 5:vertical 4:reverse 2-0:mode)
DRUN    = $D5    ; DMA count           (writing starts DMA, 0=256)
AROP    = $D6    ; DMA raster op       (2:rop_en 1-0:rop[0=NOT 1=OR 2=AND 3=XOR])
DDRW    = $D7    ; DMA data R/W        (read: reads from src++; write: writes to dest++)
DJMP    = $D8    ; DMA jump indirect   (read: indirect table jump; write: set jump table page)
DFLD    = $D9    ; DMA fast load       (read: indirect jump high-byte; write: DMA fastload [load 5 bytes])
BNK8    = $DA    ; Bank switch $8000   (low 4 bits)
BNKC    = $DB    ; Bank switch $C000   (low 4 bits)
HDML    = $DC    ; HDMA src low        (enabled in VENA)
HDMH    = $DD    ; HDMA src high
KEYB    = $DE    ; Keyboard scan (write: set row; read: scan column)
(MULW    = $DF   ; Booth multiplier (write {AL,AH,BL,BH} read {RL,RH}))

DCTL direction:                        [implementation: drives different chip-enables]
    0 = mem -> mem                     
    1 = mem -> vram                    
    2 = vram -> mem                    
    3 = vram -> vram                   (can be used for windowed scrolling)
DCTL vertical:                         (increments [Dest] by current map width in VMAP [column upload])
DCTL reverse:                          (derements src and dest addresses [memmove])
DCTL mode:
    0 = copy                           (copy bytes)
    1 = fill                           (using src low-byte)
    2 = copy transparent               (copy pixels, skip zero pixels; BPP from VCTL)
    3 = APA/ROP mode (RMW)             (uses AROP; APA addressing: low 1-3 bits of address select pixel; BPP from VCTL)
    4 = expand                         (copy and expand 1bpp to 2bpp [1 byte to 2 bytes]) ... if cheap!
    5 = palette memory                 (read src / write dest is palette memory, low-byte only; ignores direction)
    6 = sprite memory                  (read src / write dest is sprite memory, low-byte only; ignores direction)
    7 = clear sprites                  (write $FF to the Y coords of sprites, low-byte only; ignores direction)

AROP register [-----ERR] APA-mode Raster Op:
(2) Enable Raster OP
(1-0) 0=Invert 1=OR 2=AND 3=XOR

TON0    = $E0    ; PSG Ch.0 tone
PCH0    = $E1    ; PSG Ch.0 pitch
VOL0    = $E2    ; PSG Ch.0 volume
TON1    = $E3    ; PSG Ch.1 tone
PCH1    = $E4    ; PSG Ch.1 pitch
VOL1    = $E5    ; PSG Ch.1 volume
TON2    = $E6    ; PSG Ch.2 tone
PCH2    = $E7    ; PSG Ch.2 pitch
VOL2    = $E8    ; PSG Ch.2 volume
TON3    = $E9    ; PSG Ch.3 tone
PCH3    = $EA    ; PSG Ch.3 pitch
VOL3    = $EB    ; PSG Ch.3 volume
GP0R    = $EC    ; Game port 0 read
GP1R    = $ED    ; Game port 1 read
GP2R    = $EE    ; Game port 2 read       (not fitted)
GP3R    = $EF    ; Game port 3 read       (not fitted)

YLIN    = $F0    ; current Y-line         (read: V-counter; write: wait for VBlank)
YCMP    = $F1    ; compare Y-line         (read/write, $FF won't trigger)
SCRH    = $F2    ; horizontal scroll      (tile offset from 0, wraps)
SCRV    = $F3    ; vertical scroll        (row offset from 0, wraps)
FINH    = $F4    ; horizontal fine scroll (top 3 bits)
FINV    = $F5    ; vertical fine scroll   (top 3 bits)
VCTL    = $F6    ; video control          (7:APA 6:Grey 5:Double 4:HCount 3-2:VCount 1-0:Divider) (see below)
VENA    = $F7    ; interrupt enable       (7:VSync 6:VCmp 5:HSync 3:BG_En 2:Spr_En 1:HDMA_En)
VSTA    = $F8    ; interrupt status       (7:VSync 6:VCmp 5:HSync)  (read:status / write:clear)
VMAP    = $F9    ; name table size        (4:4 width 32,64,128,256; height 32,64,128,256)
VTAB    = $FA    ; name table base        (high byte)
VBNK    = $FB    ; tile bank R/W          (write: [aaaadddd] bank addr,data; read: [aaaa----] read data)
PALA    = $FC    ; palette address        (direct palette-memory address, top bit enables auto-increment)
PALD    = $FD    ; palette data R/W       (direct palette-memory data, increments address if enabled)
PALA    = $FE    ; sprite address         (direct sprite-memory address)
PALD    = $FF    ; sprite data R/W        (direct sprite-memory data, increments address)

VCTL register [AGHUVVDD] set video mode:
(7) APA mode (A) direct [non-tiled] VRAM addressing fixed at address 0
(6) Narrow mode (N) render the left 5 pixels of each tile (64-column text mode)   [not APA]
(5) 16 Color (C) attributes contain [BBBBFFFF] BG,FG colors (2x16 palettes)       [not APA]
(4) Greyscale (G) disables Colorburst for improved text legibility
(3-2) Vertical (VV) is 0=192 1=200 2=224 3=240 visible lines per frame
(1) Horizontal (H) is 0=256 1=320 visible pixel-clocks per line (shift rate)
(0) Divider (D) is 0=256|320 (2bpp) 1=128|160 (4bpp)

Pixel latch rate is determined by divider (D)
Pixel shift rate fixed, with 256/320 clocks per line (H)
In 'APA' mode, (A) and (C) are ignored.
In 'Narrow' mode (N) tiles are still 8x8x2 in memory, but only the left 5 columns are displayed.
In '16 Color' mode, 0=BG 1=FG 2=alt-BG 3=alt-FG (2x16 alt-palettes)

VENA register [VCH-BSD-] video enable:
(7) VSync Interrupt enable (V)
(6) VCmp Interrupt enable (C)
(5) HSync Interrupt enable (H)
(3) Background enable (B)
(2) Sprites enable (S)
(1) HDMA enable (D)

HDMA data format:
00000000 nnnnnnnn  - wait for YLine 'n' (sets YCMP)
00000000 FFFFFFFF  - generate HSync interrupt
aaaaaaaa dddddddd  - write byte 'd' at address 'a'

Implementation: 12-bit counter (low 16 pages), 8-bit YReg for "wait for YLine" (reuse YCMP?)

Can use HDMA to play samples (need to unpack 64 samples per frame: 64*4=256 bytes: 0,YLine,IO,sample)
every 4th line. Can unpack 1-bit delata modulation with ASL;ADC;STA loop. Too much work.



DMA APA/ROP Modes

APA mode:
Configure VRAM -> VRAM mode
Mask isolates one pixel, indexed by low bits of address.
Trigger mode: CPU writes FILL byte, triggers one DMA cycle (varying FILL or Address)
Counted mode: CPU presets FILL byte, then sets RUN count (very limited usefulness)
Read cycle -> DL
Write cycle <- DL & ~mask | FILL & mask
Write cycle <- DL & ~mask | (ROP-result) & mask
(trigger e.g. line draw, dashed line, graphics scaling)
(counted e.g. last few partial-byte pixels on a span)
[write replaces DL bits with 1/2/4 quarters of ROP-result (AND-OR)]
^ 8x 2-way AND-OR selector ~24 gates, well worth it for line/edge accel,
  especially combined with a color-latching video mode

ROP mode:
Configure VRAM -> VRAM mode
Trigger mode: CPU writes FILL byte, triggers one DMA cycle (varying FILL byte)
Counted mode: CPU presets FILL byte, then sets RUN count (constant FILL byte)
Read cycle -> DL
Write cycle <- (DL NOP|AND|OR|XOR FILL)
(trigger e.g. xor cursor draw)
(counted e.g. filled spans drawn with ROPs [demos])
[ROP-result selects (DL)|(DL-AND-FILL)|(DL-OR-FILL)|(DL-XOR-FILL) result (AND-OR)]
^ this is a lot of gates: 3*8+4*8+8 = 64, may not be worth it,
  could better spend these gates on a color-latching video mode

It may be worth including 8 XOR gates (DL XOR FILL) to provide "Invert" mode,
since that's the most common use for ROPs (cursor, selection rect)

APA bit: when set, apply APA mask (and chop 3 bits off addresses)
Trigger bit: when set, trigger one DMA cycle per FILL write.
ROP mode: COPY=0, AND=1, OR=2, XOR=3

FILL byte is shared with JTAB byte to keep register count low.

Outcome:
• implement Triggered APA as a DMA mode
• ditch ROP modes, the ROP register, and the Trigger bit
• implement a color-latching video mode instead


Selection Rect:
Horizontal: LDA DDRW; XOR $FF; STA DDRW; DEY; BNE [13 cycles/byte, 6.5 cycles/px at 4bpp]
Vertical: mask = $03 (2bpp) or $0F (4bpp) pre-shifted to pixel column.
Vertical: LDA DDRW; XOR mask; STA DDRW; DEY; BEQ done; TXA; ADC DSTL; STA DSTL; BCC loop [24 cycles/px]

Line Draw:
loop: STX DDRW; [C=0] ADC dy2; BCS step; DEC dx; BNE loop [14]  ; X steps (X=color)   step+9
step: [C=1] SBC dx2; TAY; LDA #64; CLC; ADC DSTL; STA DSTL; LDA #1; ADC DSTH; STA DSTH; TYA; DEC dx; BNE loop [33+9=42] ; Y step

(This doesn't include Y-clipping, i.e. stopping at the top/bottom edge.)

This would benefit from a fast way to increment DST by 160 or 320,
which wouldn't take a full adder: 160=128+32; 320=256+64.
Both of these can be implemented as extra increment cycles applied to
higher bits of the DST counter (b7,b5; b8,b6), manually triggered
by a CPU write (using screen mode to select the bits)

Fast-Inc Line Draw:
loop: STX DDRW; [C=0] ADC dy2; BCS step; DEY; BNE loop [13]  ; X steps (X=color)  step+9
step: STA DINC; [C=1] SBC dx2; DEY; BNE loop      [9+11=20]  ; Y step (Y=dx; DINC ignores A)

This routine only works for short lines, up to 63 in each of dx and dy,
assuming the classic 2*dx, 2*dy approach.

The midpoint formulation will work up to 127 in each of dx, dy:
D = dx/2;
for (x = x0; x <= x1; x++) {
    plot(x, y);
    D -= dy;
    if (D < 0) { y++; D += dx; }
}

Fast-Inc Line Draw:
LDA dx; ASR; SEC
loop: STX DDRW; [C=1] SBC dy; BCC step; DEY; BNE loop [13]  ; X steps, while D>=0 (X=color)
step: STA DINC; [C=0] ADC dx; DEY; BNE loop      [9+11=20]  ; Y step (Y=dx; DINC ignores A)

Fast-Inc 16-bit Line Draw:
LDA dxh; CMP #$80; ROR A; STA ehi; LDA dxl; ROR A; STA elo                                      ; CMP #$80 sets C=sign-bit
loop: STX DDRW; SEC; LDA elo; SBC dyl; STA elo; LDA ehi; SBC dyh; STA ehi; DEY; BPL loop [26]   ; X steps, while D>=0 (X=color)
step: STA DINC; CLC; LDA elo; ADC dxl; STA elo; LDA ehi; ADC dxh; STA ehi; DEY; BNE loop [+28]  ; Y step (DINC ignores A)


LDA elo; SBC dyl; STA elo; LDA ehi; SBC dyh; STA ehi;
